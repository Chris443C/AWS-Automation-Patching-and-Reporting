name: AWS Patching Automation CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean

env:
  AWS_DEFAULT_REGION: us-east-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install security tools
        run: |
          pip install bandit semgrep safety checkov
          npm install -g @aws-amplify/cli

      - name: Run Bandit Python Security Scan
        run: |
          bandit -r scripts/python/ lambda/ -f json -o bandit-report.json || true
          bandit -r scripts/python/ lambda/ -f sarif -o bandit-report.sarif || true

      - name: Run Semgrep Static Analysis
        run: |
          semgrep --config=auto --json --output=semgrep-report.json scripts/ lambda/ cloudformation/ || true
          semgrep --config=auto --sarif --output=semgrep-report.sarif scripts/ lambda/ cloudformation/ || true

      - name: Check Python dependencies for vulnerabilities
        run: |
          safety check --json --output safety-report.json || true

      - name: Run Checkov Infrastructure Security Scan
        run: |
          checkov -d cloudformation/ --framework cloudformation --output json --output-file checkov-report.json || true
          checkov -d cloudformation/ --framework cloudformation --output sarif --output-file checkov-report.sarif || true

      - name: Upload Security Scan Results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: |
            bandit-report.sarif
            semgrep-report.sarif
            checkov-report.sarif

      - name: Archive Security Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            *-report.json
            *-report.sarif
          retention-days: 30

      - name: Security Gate Check
        run: |
          python3 << 'EOF'
          import json
          import sys
          
          # Check Bandit results
          try:
              with open('bandit-report.json', 'r') as f:
                  bandit_data = json.load(f)
              
              high_severity = len([issue for issue in bandit_data.get('results', []) if issue.get('issue_severity') == 'HIGH'])
              medium_severity = len([issue for issue in bandit_data.get('results', []) if issue.get('issue_severity') == 'MEDIUM'])
              
              if high_severity > 0:
                  print(f"❌ SECURITY GATE FAILED: {high_severity} high-severity security issues found")
                  sys.exit(1)
              elif medium_severity > 5:
                  print(f"⚠️  WARNING: {medium_severity} medium-severity security issues found")
              else:
                  print(f"✅ Security scan passed: {medium_severity} medium-severity issues (acceptable)")
          except FileNotFoundError:
              print("⚠️  Bandit report not found, skipping security gate")
          
          # Check Checkov results
          try:
              with open('checkov-report.json', 'r') as f:
                  checkov_data = json.load(f)
              
              failed_checks = checkov_data.get('summary', {}).get('failed', 0)
              if failed_checks > 10:
                  print(f"❌ INFRASTRUCTURE SECURITY GATE FAILED: {failed_checks} failed security checks")
                  sys.exit(1)
              else:
                  print(f"✅ Infrastructure security scan passed: {failed_checks} failed checks (acceptable)")
          except FileNotFoundError:
              print("⚠️  Checkov report not found, skipping infrastructure security gate")
          EOF

  code-quality:
    name: Code Quality Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install quality tools
        run: |
          pip install black isort flake8 mypy pylint coverage

      - name: Check Python code formatting
        run: |
          black --check --diff scripts/python/ lambda/
          isort --check-only --diff scripts/python/ lambda/

      - name: Run linting
        run: |
          flake8 scripts/python/ lambda/ --statistics --output-file=flake8-report.txt || true
          pylint scripts/python/ lambda/ --output-format=json --reports=no > pylint-report.json || true

      - name: Run type checking
        run: |
          mypy scripts/python/ lambda/ --json-report mypy-report.json || true

      - name: Archive Quality Reports
        uses: actions/upload-artifact@v4
        with:
          name: quality-reports
          path: |
            *-report.txt
            *-report.json
          retention-days: 30

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-test.txt

      - name: Run unit tests with coverage
        run: |
          pytest tests/ \
            --cov=scripts/python \
            --cov=lambda \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-fail-under=80 \
            --junitxml=pytest-report.xml \
            -v

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            pytest-report.xml
            htmlcov/
            coverage.xml
          retention-days: 30

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        if: always()
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    services:
      localstack:
        image: localstack/localstack:latest
        ports:
          - 4566:4566
        env:
          SERVICES: lambda,s3,sns,events,stepfunctions,logs
          DEBUG: 1
        options: >-
          --health-cmd="curl -f http://localhost:4566/_localstack/health"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-test.txt
          pip install localstack[cli]

      - name: Wait for LocalStack
        run: |
          curl -f http://localhost:4566/_localstack/health
          sleep 5

      - name: Run integration tests
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          LOCALSTACK_HOST: localhost:4566
        run: |
          pytest integration_tests/ \
            --junitxml=integration-test-results.xml \
            -v --tb=short

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: integration-test-results.xml
          retention-days: 30

  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    needs: [security-scan, code-quality, unit-tests]
    if: always() && !cancelled() && !failure()
    outputs:
      version: ${{ steps.version.outputs.version }}
      artifact_bucket: ${{ steps.upload.outputs.bucket }}
      artifact_key: ${{ steps.upload.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Generate version
        id: version
        run: |
          VERSION=$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Create deployment package
        run: |
          mkdir -p dist/lambda
          
          # Package each Lambda function
          for function_dir in lambda/*/; do
            function_name=$(basename "$function_dir")
            echo "Packaging $function_name..."
            
            cd "$function_dir"
            zip -r "../../dist/lambda/${function_name}-${VERSION}.zip" . -x "*.pyc" "__pycache__/*" "tests/*"
            cd ../..
          done
          
          # Package CloudFormation templates
          mkdir -p dist/cloudformation
          cp cloudformation/*.yaml dist/cloudformation/
          
          # Package scripts
          mkdir -p dist/scripts
          cp -r scripts/* dist/scripts/
          
          # Create manifest
          cat > dist/manifest.json << EOF
          {
            "version": "$VERSION",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "git_commit": "$GITHUB_SHA",
            "git_branch": "$GITHUB_REF_NAME",
            "build_number": "$GITHUB_RUN_NUMBER",
            "components": {
              "lambda_functions": $(ls dist/lambda/*.zip | wc -l),
              "cloudformation_templates": $(ls dist/cloudformation/*.yaml | wc -l),
              "scripts": $(find dist/scripts -type f | wc -l)
            }
          }
          EOF

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Upload artifacts to S3
        id: upload
        run: |
          BUCKET_NAME="patching-automation-artifacts-${{ github.repository_owner }}"
          ARTIFACT_KEY="builds/${VERSION}/patching-automation-${VERSION}.tar.gz"
          
          # Create tarball
          cd dist
          tar -czf "../patching-automation-${VERSION}.tar.gz" .
          cd ..
          
          # Upload to S3
          aws s3 cp "patching-automation-${VERSION}.tar.gz" "s3://${BUCKET_NAME}/${ARTIFACT_KEY}"
          
          echo "bucket=$BUCKET_NAME" >> $GITHUB_OUTPUT
          echo "key=$ARTIFACT_KEY" >> $GITHUB_OUTPUT

      - name: Archive build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ steps.version.outputs.version }}
          path: dist/
          retention-days: 90

  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-and-package, integration-tests]
    if: |
      always() && !cancelled() && !failure() &&
      (github.ref == 'refs/heads/develop' || 
       (github.event_name == 'workflow_dispatch' && inputs.environment == 'dev'))
    environment: 
      name: dev
      url: ${{ steps.deploy.outputs.dashboard_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.build-and-package.outputs.version }}
          path: dist/

      - name: Deploy infrastructure
        id: deploy
        run: |
          VERSION="${{ needs.build-and-package.outputs.version }}"
          
          # Deploy EventBridge stack
          aws cloudformation deploy \
            --template-file dist/cloudformation/eventbridge-stack.yaml \
            --stack-name patching-automation-eventbridge-dev \
            --parameter-overrides Environment=dev \
            --capabilities CAPABILITY_NAMED_IAM \
            --tags Environment=dev Version=$VERSION

          # Deploy observability stack
          aws cloudformation deploy \
            --template-file dist/cloudformation/observability-stack.yaml \
            --stack-name patching-automation-observability-dev \
            --parameter-overrides Environment=dev \
            --capabilities CAPABILITY_NAMED_IAM \
            --tags Environment=dev Version=$VERSION

          # Get EventBridge outputs
          EVENT_BUS_NAME=$(aws cloudformation describe-stacks \
            --stack-name patching-automation-eventbridge-dev \
            --query 'Stacks[0].Outputs[?OutputKey==`EventBusName`].OutputValue' \
            --output text)

          # Deploy Step Functions stack
          aws cloudformation deploy \
            --template-file dist/cloudformation/step-functions-stack.yaml \
            --stack-name patching-automation-stepfunctions-dev \
            --parameter-overrides \
              Environment=dev \
              EventBusName=$EVENT_BUS_NAME \
              ComplianceScannerFunctionArn="$(aws lambda get-function --function-name compliance-scanner-microservice-dev --query 'Configuration.FunctionArn' --output text || echo 'arn:aws:lambda:us-east-1:123456789012:function:placeholder')" \
              VulnerabilityScannerFunctionArn="$(aws lambda get-function --function-name vulnerability-scanner-microservice-dev --query 'Configuration.FunctionArn' --output text || echo 'arn:aws:lambda:us-east-1:123456789012:function:placeholder')" \
              PatchApproverFunctionArn="$(aws lambda get-function --function-name patch-approver-microservice-dev --query 'Configuration.FunctionArn' --output text || echo 'arn:aws:lambda:us-east-1:123456789012:function:placeholder')" \
              NotificationServiceFunctionArn="$(aws lambda get-function --function-name notification-service-microservice-dev --query 'Configuration.FunctionArn' --output text || echo 'arn:aws:lambda:us-east-1:123456789012:function:placeholder')" \
            --capabilities CAPABILITY_NAMED_IAM \
            --tags Environment=dev Version=$VERSION

          # Get dashboard URL
          DASHBOARD_URL=$(aws cloudformation describe-stacks \
            --stack-name patching-automation-observability-dev \
            --query 'Stacks[0].Outputs[?OutputKey==`DashboardURL`].OutputValue' \
            --output text)

          echo "dashboard_url=$DASHBOARD_URL" >> $GITHUB_OUTPUT

      - name: Run deployment tests
        run: |
          # Test EventBridge
          aws events list-rules --event-bus-name patching-automation-dev

          # Test Step Functions
          aws stepfunctions list-state-machines | grep -q "patch-approval-workflow-dev"

          echo "✅ Deployment tests passed"

      - name: Update deployment status
        if: always()
        run: |
          STATUS="${{ job.status }}"
          VERSION="${{ needs.build-and-package.outputs.version }}"
          
          aws ssm put-parameter \
            --name "/patching-automation/dev/deployment/status" \
            --value "{\"status\":\"$STATUS\",\"version\":\"$VERSION\",\"timestamp\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"dashboard_url\":\"${{ steps.deploy.outputs.dashboard_url }}\"}" \
            --type String \
            --overwrite

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-dev]
    if: |
      always() && !cancelled() && !failure() &&
      (github.ref == 'refs/heads/main' || 
       (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging'))
    environment: 
      name: staging
      url: ${{ steps.deploy.outputs.dashboard_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.build-and-package.outputs.version }}
          path: dist/

      - name: Deploy to staging
        id: deploy
        run: |
          VERSION="${{ needs.build-and-package.outputs.version }}"
          echo "Deploying version $VERSION to staging..."
          
          # Similar deployment steps as dev but with staging parameters
          # This would include blue-green deployment logic for staging
          
          echo "dashboard_url=https://staging-dashboard.example.com" >> $GITHUB_OUTPUT

      - name: Run smoke tests
        run: |
          echo "Running staging smoke tests..."
          # Add staging-specific tests here

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-staging]
    if: |
      always() && !cancelled() && !failure() &&
      github.ref == 'refs/heads/main' && 
      github.event_name == 'push'
    environment: 
      name: production
      url: ${{ steps.deploy.outputs.dashboard_url }}
    steps:
      - name: Production deployment approval
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ secrets.PROD_APPROVERS }}
          minimum-approvals: 2
          issue-title: "Production Deployment Approval Required"
          issue-body: |
            Please approve the production deployment of version ${{ needs.build-and-package.outputs.version }}
            
            **Changes:**
            ${{ github.event.head_commit.message }}
            
            **Staging Tests:** Passed ✅
            **Security Scan:** Passed ✅
            
            **Deployment Details:**
            - Version: ${{ needs.build-and-package.outputs.version }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.build-and-package.outputs.version }}
          path: dist/

      - name: Blue-Green Production Deployment
        id: deploy
        run: |
          VERSION="${{ needs.build-and-package.outputs.version }}"
          echo "Starting blue-green deployment of version $VERSION to production..."
          
          # Implement blue-green deployment logic
          # This would include:
          # 1. Deploy to green environment
          # 2. Run health checks
          # 3. Switch traffic
          # 4. Monitor metrics
          # 5. Rollback if needed
          
          echo "dashboard_url=https://prod-dashboard.example.com" >> $GITHUB_OUTPUT

      - name: Production health checks
        run: |
          echo "Running production health checks..."
          # Add comprehensive health checks

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            🚀 Production deployment successful!
            Version: ${{ needs.build-and-package.outputs.version }}
            Dashboard: ${{ steps.deploy.outputs.dashboard_url }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-dev, deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Clean up old artifacts
        run: |
          echo "Cleaning up old build artifacts..."
          # Implement cleanup logic for old S3 artifacts
          # Keep last 10 builds, remove older ones

      - name: Update deployment metrics
        run: |
          echo "Updating deployment metrics..."
          # Send deployment metrics to monitoring system