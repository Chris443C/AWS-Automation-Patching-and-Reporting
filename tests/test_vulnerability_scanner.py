#!/usr/bin/env python3
"""
Unit tests for Vulnerability Scanner Microservice
"""

import pytest
import json
import boto3
from unittest.mock import Mock, patch, MagicMock
from moto import mock_inspector2, mock_ssm, mock_ec2, mock_events, mock_cloudwatch
from datetime import datetime, timedelta

# Import the module under test
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'lambda', 'vulnerability-scanner'))

from vulnerability_scanner_microservice import VulnerabilityScannerMicroservice, lambda_handler


class TestVulnerabilityScannerMicroservice:
    """Test cases for VulnerabilityScannerMicroservice"""
    
    @mock_inspector2
    @mock_ssm
    @mock_ec2
    @mock_events
    @mock_cloudwatch
    def test_init(self):
        """Test microservice initialization"""
        with patch.dict(os.environ, {
            'AWS_REGION': 'us-west-2',
            'ENVIRONMENT': 'test',
            'EVENT_BUS_NAME': 'test-bus'
        }):
            scanner = VulnerabilityScannerMicroservice()
            
            assert scanner.region == 'us-west-2'
            assert scanner.environment == 'test'
            assert scanner.event_bus_name == 'test-bus'
            assert scanner.correlation_id is not None
    
    @mock_inspector2
    def test_get_inspector_findings(self):
        """Test Inspector findings retrieval"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # Mock Inspector response
            mock_findings = [
                {
                    'findingArn': 'arn:aws:inspector2:us-east-1:123456789012:finding/finding-1',
                    'title': 'CVE-2021-44228 - Log4j Vulnerability',
                    'severity': 'CRITICAL',
                    'firstObservedAt': datetime.utcnow().isoformat() + 'Z',
                    'status': 'ACTIVE'
                }
            ]
            
            with patch.object(scanner.inspector, 'get_paginator') as mock_paginator:
                mock_paginate = Mock()
                mock_paginate.paginate.return_value = [{'findings': mock_findings}]
                mock_paginator.return_value = mock_paginate
                
                scan_params = {'days_back': 7}
                findings = scanner._get_inspector_findings(scan_params)
                
                assert len(findings) == 1
                assert findings[0]['title'] == 'CVE-2021-44228 - Log4j Vulnerability'
    
    @mock_ssm
    def test_get_available_patches(self):
        """Test available patches retrieval"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # Mock SSM responses
            mock_instances = [
                {
                    'InstanceId': 'i-1234567890abcdef0',
                    'PingStatus': 'Online',
                    'PlatformType': 'Linux'
                }
            ]
            
            mock_patches = [
                {
                    'Id': 'KB4012212',
                    'Title': 'Security Update for Windows',
                    'Classification': 'SecurityUpdates',
                    'Severity': 'Critical',
                    'State': 'Missing',
                    'KBId': 'KB4012212'
                }
            ]
            
            with patch.object(scanner, '_get_managed_instances', return_value=['i-1234567890abcdef0']):
                with patch.object(scanner.ssm, 'describe_instance_patch_states') as mock_patch_states:
                    with patch.object(scanner.ssm, 'describe_instance_patches') as mock_patches_call:
                        mock_patch_states.return_value = {
                            'InstancePatchStates': [{'InstanceId': 'i-1234567890abcdef0'}]
                        }
                        mock_patches_call.return_value = {'Patches': mock_patches}
                        
                        scan_params = {}
                        patches = scanner._get_available_patches(scan_params)
                        
                        assert len(patches) == 1
                        assert patches[0]['patch_id'] == 'KB4012212'
                        assert patches[0]['instance_id'] == 'i-1234567890abcdef0'
    
    def test_correlate_vulnerabilities_with_patches(self):
        """Test vulnerability-patch correlation"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            vulnerabilities = [
                {
                    'findingArn': 'arn:aws:inspector2:us-east-1:123456789012:finding/finding-1',
                    'title': 'CVE-2021-44228 Log4j vulnerability',
                    'severity': 'CRITICAL',
                    'vulnerabilityId': 'CVE-2021-44228'
                }
            ]
            
            patches = [
                {
                    'instance_id': 'i-1234567890abcdef0',
                    'patch_id': 'KB5008212',
                    'title': 'Security Update for Log4j CVE-2021-44228',
                    'severity': 'Critical',
                    'kb_id': 'KB5008212'
                }
            ]
            
            correlation = scanner._correlate_vulnerabilities_with_patches(vulnerabilities, patches)
            
            assert len(correlation['correlated_items']) == 1
            assert correlation['correlated_items'][0]['correlation_score'] > 0.5
    
    def test_analyze_vulnerabilities(self):
        """Test vulnerability analysis"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            correlation = {
                'correlated_items': [
                    {
                        'vulnerability': {'severity': 'CRITICAL', 'findingArn': 'arn:test'},
                        'patch': {'patch_id': 'KB123', 'instance_id': 'i-123'},
                        'correlation_score': 0.9
                    }
                ],
                'unpatched_vulnerabilities': [
                    {'severity': 'HIGH', 'findingArn': 'arn:test2'}
                ]
            }
            
            analysis = scanner._analyze_vulnerabilities(correlation)
            
            assert analysis['total_vulnerabilities'] == 2
            assert analysis['patchable_vulnerabilities'] == 1
            assert analysis['critical_count'] == 1
            assert analysis['high_count'] == 1
            assert len(analysis['priority_matrix']) == 1
    
    def test_calculate_priority_score(self):
        """Test priority score calculation"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # Critical vulnerability should have high priority
            critical_vuln = {'severity': 'CRITICAL', 'firstObservedAt': datetime.utcnow().isoformat() + 'Z'}
            patch = {'severity': 'Critical'}
            
            score = scanner._calculate_priority_score(critical_vuln, patch)
            assert score >= 8.0  # Should be high priority
            
            # Low vulnerability should have lower priority
            low_vuln = {'severity': 'LOW'}
            low_score = scanner._calculate_priority_score(low_vuln, patch)
            assert low_score < score
    
    def test_get_recommended_action(self):
        """Test recommended action logic"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # Critical with high correlation should be immediate patch
            action = scanner._get_recommended_action('CRITICAL', 0.9)
            assert action == 'IMMEDIATE_PATCH'
            
            # Critical with low correlation should be investigation
            action = scanner._get_recommended_action('CRITICAL', 0.5)
            assert action == 'URGENT_INVESTIGATION'
            
            # High severity should be scheduled patch
            action = scanner._get_recommended_action('HIGH', 0.8)
            assert action == 'SCHEDULE_PATCH'
            
            # Medium severity should be monitor
            action = scanner._get_recommended_action('MEDIUM', 0.5)
            assert action == 'MONITOR'
    
    @mock_cloudwatch
    def test_record_vulnerability_metrics(self):
        """Test vulnerability metrics recording"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            analysis = {
                'total_vulnerabilities': 15,
                'critical_count': 3,
                'high_count': 5,
                'patchable_vulnerabilities': 10
            }
            
            with patch.object(scanner.cloudwatch, 'put_metric_data') as mock_put_metric:
                scanner._record_vulnerability_metrics(analysis)
                
                # Verify metric data was sent
                mock_put_metric.assert_called_once()
                args, kwargs = mock_put_metric.call_args
                
                assert kwargs['Namespace'] == 'AWS/PatchingAutomation/Microservices'
                assert len(kwargs['MetricData']) == 4  # 4 metrics
    
    def test_extract_cve_id(self):
        """Test CVE ID extraction"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # Test CVE in title
            vuln1 = {'title': 'CVE-2021-44228 Log4j vulnerability'}
            cve1 = scanner._extract_cve_id(vuln1)
            assert cve1 == 'CVE-2021-44228'
            
            # Test CVE in vulnerabilityId
            vuln2 = {'vulnerabilityId': 'CVE-2022-1234'}
            cve2 = scanner._extract_cve_id(vuln2)
            assert cve2 == 'CVE-2022-1234'
            
            # Test no CVE
            vuln3 = {'title': 'Generic security issue'}
            cve3 = scanner._extract_cve_id(vuln3)
            assert cve3 is None
    
    def test_calculate_title_similarity(self):
        """Test title similarity calculation"""
        with patch.dict(os.environ, {'AWS_REGION': 'us-east-1', 'ENVIRONMENT': 'test'}):
            scanner = VulnerabilityScannerMicroservice()
            
            # High similarity
            title1 = "Security Update for Log4j"
            title2 = "Log4j Security Update"
            similarity = scanner._calculate_title_similarity(title1, title2)
            assert similarity > 0.5
            
            # Low similarity
            title3 = "Windows Update"
            similarity2 = scanner._calculate_title_similarity(title1, title3)
            assert similarity2 < 0.3
            
            # Identical titles
            similarity3 = scanner._calculate_title_similarity(title1, title1)
            assert similarity3 == 1.0


class TestLambdaHandler:
    """Test cases for lambda_handler function"""
    
    @mock_inspector2
    @mock_ssm
    @mock_ec2
    @mock_events
    @mock_cloudwatch
    def test_lambda_handler_success(self):
        """Test successful lambda handler execution"""
        with patch.dict(os.environ, {
            'AWS_REGION': 'us-east-1',
            'ENVIRONMENT': 'test',
            'EVENT_BUS_NAME': 'test-bus'
        }):
            # Mock context
            context = Mock()
            context.function_name = 'test-function'
            context.function_version = '1.0'
            
            # Mock event
            event = {
                'scanType': 'targeted',
                'daysBack': 5,
                'includeInspector': True,
                'includePatches': True
            }
            
            # Mock the scan_vulnerabilities method
            with patch('vulnerability_scanner_microservice.VulnerabilityScannerMicroservice.scan_vulnerabilities') as mock_scan:
                mock_scan.return_value = {
                    'status': 'completed',
                    'correlation_id': 'test-id',
                    'vulnerabilities_count': 10,
                    'patches_count': 5,
                    'critical_vulnerabilities': 2,
                    'high_vulnerabilities': 3
                }
                
                response = lambda_handler(event, context)
                
                assert response['statusCode'] == 200
                body = json.loads(response['body'])
                assert body['status'] == 'completed'
                assert body['critical_vulnerabilities'] == 2
    
    @mock_inspector2
    @mock_ssm
    @mock_ec2
    @mock_events
    @mock_cloudwatch
    def test_lambda_handler_error(self):
        """Test lambda handler error handling"""
        with patch.dict(os.environ, {
            'AWS_REGION': 'us-east-1',
            'ENVIRONMENT': 'test',
            'EVENT_BUS_NAME': 'test-bus'
        }):
            # Mock context
            context = Mock()
            context.function_name = 'test-function'
            context.function_version = '1.0'
            
            # Mock event
            event = {'scanType': 'invalid'}
            
            # Mock the scan_vulnerabilities method to raise exception
            with patch('vulnerability_scanner_microservice.VulnerabilityScannerMicroservice.scan_vulnerabilities') as mock_scan:
                mock_scan.side_effect = Exception('Test error')
                
                response = lambda_handler(event, context)
                
                assert response['statusCode'] == 500
                body = json.loads(response['body'])
                assert 'error' in body
                assert body['error'] == 'Test error'


if __name__ == '__main__':
    pytest.main([__file__])