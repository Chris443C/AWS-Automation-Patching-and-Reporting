#!/usr/bin/env python3
"""
Vulnerability Scanner Microservice
Specialized microservice for vulnerability detection and patch identification
"""

import json
import boto3
import os
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import aws_xray_sdk.core
from aws_xray_sdk.core import xray_recorder, patch_all
from botocore.exceptions import ClientError

# Configure X-Ray tracing
patch_all()

# Configure structured logging
import structlog

structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="ISO"),
        structlog.processors.JSONRenderer()
    ],
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

class VulnerabilityScannerMicroservice:
    """Microservice for vulnerability scanning and patch identification"""
    
    def __init__(self):
        self.region = os.environ.get('AWS_REGION', 'us-east-1')
        self.environment = os.environ.get('ENVIRONMENT', 'dev')
        self.event_bus_name = os.environ.get('EVENT_BUS_NAME')
        
        # AWS clients with X-Ray tracing
        self.inspector = boto3.client('inspector2', region_name=self.region)
        self.ssm = boto3.client('ssm', region_name=self.region)
        self.ec2 = boto3.client('ec2', region_name=self.region)
        self.events_client = boto3.client('events', region_name=self.region)
        self.cloudwatch = boto3.client('cloudwatch', region_name=self.region)
        
        # Correlation ID for request tracing
        self.correlation_id = str(uuid.uuid4())
    
    @xray_recorder.capture('vulnerability_scan')
    def scan_vulnerabilities(self, scan_params: Dict[str, Any]) -> Dict[str, Any]:
        """Perform vulnerability scanning"""
        logger.info(
            "vulnerability_scan_started",
            correlation_id=self.correlation_id,
            scan_type=scan_params.get('scan_type', 'patches'),
            environment=self.environment
        )
        
        try:
            # Get vulnerability findings from Inspector
            vulnerabilities = self._get_inspector_findings(scan_params)
            
            # Get available patches
            patches = self._get_available_patches(scan_params)
            
            # Correlate vulnerabilities with patches
            correlation = self._correlate_vulnerabilities_with_patches(vulnerabilities, patches)
            
            # Analyze severity and prioritize
            analysis = self._analyze_vulnerabilities(correlation)
            
            # Publish vulnerability events
            await self._publish_vulnerability_events(analysis)
            
            # Record metrics
            self._record_vulnerability_metrics(analysis)
            
            result = {
                'status': 'completed',
                'correlation_id': self.correlation_id,
                'vulnerabilities_count': len(vulnerabilities),
                'patches_count': len(patches),
                'critical_vulnerabilities': analysis['critical_count'],
                'high_vulnerabilities': analysis['high_count'],
                'scan_timestamp': datetime.utcnow().isoformat()
            }
            
            logger.info(
                "vulnerability_scan_completed",
                correlation_id=self.correlation_id,
                **result
            )
            
            return result
            
        except Exception as e:
            logger.error(
                "vulnerability_scan_failed",
                correlation_id=self.correlation_id,
                error=str(e),
                error_type=type(e).__name__
            )
            
            # Record failure metric
            self._record_failure_metric('vulnerability_scan_failure')
            raise
    
    @xray_recorder.capture('get_inspector_findings')
    def _get_inspector_findings(self, scan_params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get vulnerability findings from AWS Inspector"""
        findings = []
        
        try:
            # Build filters for Inspector findings
            filters = {
                'findingStatus': [
                    {'comparison': 'EQUALS', 'value': 'ACTIVE'}
                ],
                'severity': [
                    {'comparison': 'EQUALS', 'value': 'CRITICAL'},
                    {'comparison': 'EQUALS', 'value': 'HIGH'},
                    {'comparison': 'EQUALS', 'value': 'MEDIUM'}
                ]
            }
            
            # Add date filter if specified
            if 'days_back' in scan_params:
                start_date = datetime.utcnow() - timedelta(days=scan_params['days_back'])
                filters['firstObservedAt'] = [
                    {
                        'startInclusive': start_date.isoformat() + 'Z'
                    }
                ]
            
            # Get findings with pagination
            paginator = self.inspector.get_paginator('list_findings')
            
            with xray_recorder.in_subsegment('inspector_api_calls'):
                for page in paginator.paginate(
                    filterCriteria=filters,
                    maxResults=100
                ):
                    page_findings = page.get('findings', [])
                    findings.extend(page_findings)
                    
                    # Add annotation for X-Ray
                    xray_recorder.current_subsegment().put_annotation(
                        'inspector_findings_page_size', 
                        len(page_findings)
                    )
            
            logger.info(
                "inspector_findings_retrieved",
                correlation_id=self.correlation_id,
                findings_count=len(findings)
            )
            
        except Exception as e:
            logger.error(
                "failed_to_get_inspector_findings",
                correlation_id=self.correlation_id,
                error=str(e)
            )
            # Continue with empty findings rather than failing
            
        return findings
    
    @xray_recorder.capture('get_available_patches')
    def _get_available_patches(self, scan_params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get available patches from Systems Manager"""
        patches = []
        
        try:
            # Get managed instances
            instances = self._get_managed_instances()
            
            with xray_recorder.in_subsegment('get_patch_states'):
                for instance_batch in self._batch_instances(instances, batch_size=10):
                    try:
                        # Get patch states for batch of instances
                        response = self.ssm.describe_instance_patch_states(
                            InstanceIds=instance_batch
                        )
                        
                        for patch_state in response.get('InstancePatchStates', []):
                            instance_id = patch_state['InstanceId']
                            
                            # Get missing patches for this instance
                            missing_patches = self.ssm.describe_instance_patches(
                                InstanceId=instance_id,
                                Filters=[
                                    {
                                        'Key': 'STATE',
                                        'Values': ['Missing', 'Failed']
                                    }
                                ],
                                MaxResults=50
                            )
                            
                            for patch in missing_patches.get('Patches', []):
                                patches.append({
                                    'instance_id': instance_id,
                                    'patch_id': patch.get('Id'),
                                    'title': patch.get('Title'),
                                    'classification': patch.get('Classification'),
                                    'severity': patch.get('Severity'),
                                    'kb_id': patch.get('KBId'),
                                    'product': patch.get('Product'),
                                    'release_date': patch.get('ReleaseDate'),
                                    'state': patch.get('State')
                                })
                    
                    except Exception as e:
                        logger.warning(
                            "failed_to_get_patches_for_instances",
                            correlation_id=self.correlation_id,
                            instance_batch=instance_batch,
                            error=str(e)
                        )
                        continue
            
            logger.info(
                "patches_retrieved",
                correlation_id=self.correlation_id,
                patches_count=len(patches)
            )
            
        except Exception as e:
            logger.error(
                "failed_to_get_available_patches",
                correlation_id=self.correlation_id,
                error=str(e)
            )
        
        return patches
    
    def _get_managed_instances(self) -> List[str]:
        """Get list of managed EC2 instances"""
        instance_ids = []
        
        try:
            # Get instances with SSM agent
            response = self.ssm.describe_instance_information(
                Filters=[
                    {
                        'Key': 'PingStatus',
                        'Values': ['Online']
                    }
                ],
                MaxResults=50
            )
            
            instance_ids = [
                instance['InstanceId'] 
                for instance in response.get('InstanceInformationList', [])
                if instance.get('PlatformType') in ['Windows', 'Linux']
            ]
            
        except Exception as e:
            logger.warning(
                "failed_to_get_managed_instances",
                correlation_id=self.correlation_id,
                error=str(e)
            )
        
        return instance_ids
    
    def _batch_instances(self, instances: List[str], batch_size: int = 10) -> List[List[str]]:
        """Batch instances for processing"""
        for i in range(0, len(instances), batch_size):
            yield instances[i:i + batch_size]
    
    @xray_recorder.capture('correlate_vulnerabilities_with_patches')
    def _correlate_vulnerabilities_with_patches(
        self, 
        vulnerabilities: List[Dict[str, Any]], 
        patches: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Correlate vulnerabilities with available patches"""
        
        correlation = {
            'correlated_items': [],
            'unpatched_vulnerabilities': [],
            'orphaned_patches': []
        }
        
        # Create lookup maps
        vulnerability_map = {}
        for vuln in vulnerabilities:
            cve_id = self._extract_cve_id(vuln)
            if cve_id:
                vulnerability_map[cve_id] = vuln
        
        patch_map = {}
        for patch in patches:
            kb_id = patch.get('kb_id')
            if kb_id:
                if kb_id not in patch_map:
                    patch_map[kb_id] = []
                patch_map[kb_id].append(patch)
        
        # Correlate vulnerabilities with patches
        matched_vulnerabilities = set()
        matched_patches = set()
        
        for vuln in vulnerabilities:
            cve_id = self._extract_cve_id(vuln)
            title = vuln.get('title', '').lower()
            
            for kb_id, patch_list in patch_map.items():
                for patch in patch_list:
                    patch_title = patch.get('title', '').lower()
                    
                    # Simple correlation based on title similarity or CVE ID
                    if (cve_id and cve_id in patch_title) or \
                       (self._calculate_title_similarity(title, patch_title) > 0.7):
                        
                        correlation['correlated_items'].append({
                            'vulnerability': vuln,
                            'patch': patch,
                            'correlation_score': self._calculate_correlation_score(vuln, patch)
                        })
                        
                        matched_vulnerabilities.add(id(vuln))
                        matched_patches.add(id(patch))
                        break
        
        # Find unmatched items
        correlation['unpatched_vulnerabilities'] = [
            vuln for vuln in vulnerabilities 
            if id(vuln) not in matched_vulnerabilities
        ]
        
        correlation['orphaned_patches'] = [
            patch for patch_list in patch_map.values() 
            for patch in patch_list 
            if id(patch) not in matched_patches
        ]
        
        return correlation
    
    def _extract_cve_id(self, vulnerability: Dict[str, Any]) -> Optional[str]:
        """Extract CVE ID from vulnerability finding"""
        # Look for CVE ID in various fields
        fields_to_check = ['title', 'description', 'vulnerabilityId']
        
        for field in fields_to_check:
            if field in vulnerability:
                text = str(vulnerability[field]).upper()
                # Simple regex to find CVE-YYYY-NNNN pattern
                import re
                cve_match = re.search(r'CVE-\d{4}-\d{4,7}', text)
                if cve_match:
                    return cve_match.group(0)
        
        return None
    
    def _calculate_title_similarity(self, title1: str, title2: str) -> float:
        """Calculate similarity between two titles"""
        # Simple word-based similarity
        words1 = set(title1.lower().split())
        words2 = set(title2.lower().split())
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        if not union:
            return 0.0
        
        return len(intersection) / len(union)
    
    def _calculate_correlation_score(self, vulnerability: Dict[str, Any], patch: Dict[str, Any]) -> float:
        """Calculate correlation score between vulnerability and patch"""
        score = 0.0
        
        # Severity matching
        vuln_severity = vulnerability.get('severity', '').upper()
        patch_severity = patch.get('severity', '').upper()
        
        if vuln_severity == patch_severity:
            score += 0.3
        
        # Title similarity
        title_similarity = self._calculate_title_similarity(
            vulnerability.get('title', ''),
            patch.get('title', '')
        )
        score += title_similarity * 0.7
        
        return min(1.0, score)
    
    @xray_recorder.capture('analyze_vulnerabilities')
    def _analyze_vulnerabilities(self, correlation: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze vulnerabilities and create priority matrix"""
        analysis = {
            'total_vulnerabilities': len(correlation.get('correlated_items', [])) + len(correlation.get('unpatched_vulnerabilities', [])),
            'patchable_vulnerabilities': len(correlation.get('correlated_items', [])),
            'unpatched_vulnerabilities': len(correlation.get('unpatched_vulnerabilities', [])),
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'priority_matrix': []
        }
        
        # Analyze correlated items
        for item in correlation.get('correlated_items', []):
            vulnerability = item['vulnerability']
            patch = item['patch']
            
            severity = vulnerability.get('severity', 'UNKNOWN').upper()
            
            # Count by severity
            if severity == 'CRITICAL':
                analysis['critical_count'] += 1
            elif severity == 'HIGH':
                analysis['high_count'] += 1
            elif severity == 'MEDIUM':
                analysis['medium_count'] += 1
            elif severity == 'LOW':
                analysis['low_count'] += 1
            
            # Create priority item
            priority_item = {
                'vulnerability_id': vulnerability.get('findingArn'),
                'patch_id': patch.get('patch_id'),
                'severity': severity,
                'correlation_score': item['correlation_score'],
                'priority_score': self._calculate_priority_score(vulnerability, patch),
                'instance_id': patch.get('instance_id'),
                'recommended_action': self._get_recommended_action(severity, item['correlation_score'])
            }
            
            analysis['priority_matrix'].append(priority_item)
        
        # Analyze unpatched vulnerabilities
        for vulnerability in correlation.get('unpatched_vulnerabilities', []):
            severity = vulnerability.get('severity', 'UNKNOWN').upper()
            
            if severity == 'CRITICAL':
                analysis['critical_count'] += 1
            elif severity == 'HIGH':
                analysis['high_count'] += 1
            elif severity == 'MEDIUM':
                analysis['medium_count'] += 1
            elif severity == 'LOW':
                analysis['low_count'] += 1
        
        # Sort priority matrix by priority score
        analysis['priority_matrix'].sort(key=lambda x: x['priority_score'], reverse=True)
        
        return analysis
    
    def _calculate_priority_score(self, vulnerability: Dict[str, Any], patch: Dict[str, Any]) -> float:
        """Calculate priority score for vulnerability-patch pair"""
        score = 0.0
        
        # Severity weight
        severity_weights = {
            'CRITICAL': 10.0,
            'HIGH': 7.0,
            'MEDIUM': 4.0,
            'LOW': 1.0
        }
        
        severity = vulnerability.get('severity', 'LOW').upper()
        score += severity_weights.get(severity, 0.0)
        
        # Age factor (newer vulnerabilities get higher priority)
        try:
            first_observed = vulnerability.get('firstObservedAt')
            if first_observed:
                from datetime import datetime
                observed_date = datetime.fromisoformat(first_observed.replace('Z', '+00:00'))
                age_days = (datetime.now(observed_date.tzinfo) - observed_date).days
                age_factor = max(0.1, 1.0 - (age_days / 365.0))  # Decay over a year
                score *= age_factor
        except:
            pass
        
        return score
    
    def _get_recommended_action(self, severity: str, correlation_score: float) -> str:
        """Get recommended action based on severity and correlation"""
        if severity == 'CRITICAL':
            if correlation_score > 0.8:
                return 'IMMEDIATE_PATCH'
            else:
                return 'URGENT_INVESTIGATION'
        elif severity == 'HIGH':
            if correlation_score > 0.7:
                return 'SCHEDULE_PATCH'
            else:
                return 'INVESTIGATE'
        else:
            return 'MONITOR'
    
    async def _publish_vulnerability_events(self, analysis: Dict[str, Any]):
        """Publish vulnerability events to EventBridge"""
        events = []
        
        # Publish critical vulnerability events
        if analysis['critical_count'] > 0:
            events.append({
                'Source': 'patching-automation.vulnerability-scanner',
                'DetailType': 'Critical Vulnerabilities Detected',
                'Detail': json.dumps({
                    'correlation_id': self.correlation_id,
                    'environment': self.environment,
                    'critical_count': analysis['critical_count'],
                    'high_count': analysis['high_count'],
                    'total_vulnerabilities': analysis['total_vulnerabilities'],
                    'patchable_vulnerabilities': analysis['patchable_vulnerabilities'],
                    'timestamp': datetime.utcnow().isoformat()
                }),
                'EventBusName': self.event_bus_name
            })
        
        # Publish vulnerability scan completed event
        events.append({
            'Source': 'patching-automation.vulnerability-scanner',
            'DetailType': 'Vulnerability Scan Completed',
            'Detail': json.dumps({
                'correlation_id': self.correlation_id,
                'environment': self.environment,
                'status': 'completed',
                'total_vulnerabilities': analysis['total_vulnerabilities'],
                'critical_count': analysis['critical_count'],
                'high_count': analysis['high_count'],
                'patchable_count': analysis['patchable_vulnerabilities'],
                'timestamp': datetime.utcnow().isoformat()
            }),
            'EventBusName': self.event_bus_name
        })
        
        if events and self.event_bus_name:
            try:
                self.events_client.put_events(Entries=events)
                logger.info(
                    "vulnerability_events_published",
                    correlation_id=self.correlation_id,
                    events_count=len(events)
                )
            except Exception as e:
                logger.error(
                    "failed_to_publish_vulnerability_events",
                    correlation_id=self.correlation_id,
                    error=str(e)
                )
    
    def _record_vulnerability_metrics(self, analysis: Dict[str, Any]):
        """Record vulnerability metrics to CloudWatch"""
        try:
            metric_data = [
                {
                    'MetricName': 'TotalVulnerabilities',
                    'Value': analysis['total_vulnerabilities'],
                    'Unit': 'Count',
                    'Dimensions': [
                        {'Name': 'Environment', 'Value': self.environment},
                        {'Name': 'Service', 'Value': 'VulnerabilityScanner'}
                    ]
                },
                {
                    'MetricName': 'CriticalVulnerabilities',
                    'Value': analysis['critical_count'],
                    'Unit': 'Count',
                    'Dimensions': [
                        {'Name': 'Environment', 'Value': self.environment},
                        {'Name': 'Service', 'Value': 'VulnerabilityScanner'}
                    ]
                },
                {
                    'MetricName': 'HighVulnerabilities',
                    'Value': analysis['high_count'],
                    'Unit': 'Count',
                    'Dimensions': [
                        {'Name': 'Environment', 'Value': self.environment},
                        {'Name': 'Service', 'Value': 'VulnerabilityScanner'}
                    ]
                },
                {
                    'MetricName': 'PatchableVulnerabilities',
                    'Value': analysis['patchable_vulnerabilities'],
                    'Unit': 'Count',
                    'Dimensions': [
                        {'Name': 'Environment', 'Value': self.environment},
                        {'Name': 'Service', 'Value': 'VulnerabilityScanner'}
                    ]
                }
            ]
            
            self.cloudwatch.put_metric_data(
                Namespace='AWS/PatchingAutomation/Microservices',
                MetricData=metric_data
            )
            
            logger.info(
                "vulnerability_metrics_recorded",
                correlation_id=self.correlation_id,
                metrics_count=len(metric_data)
            )
            
        except Exception as e:
            logger.error(
                "failed_to_record_vulnerability_metrics",
                correlation_id=self.correlation_id,
                error=str(e)
            )
    
    def _record_failure_metric(self, failure_type: str):
        """Record failure metrics"""
        try:
            self.cloudwatch.put_metric_data(
                Namespace='AWS/PatchingAutomation/Microservices',
                MetricData=[
                    {
                        'MetricName': 'Failures',
                        'Value': 1,
                        'Unit': 'Count',
                        'Dimensions': [
                            {'Name': 'Environment', 'Value': self.environment},
                            {'Name': 'Service', 'Value': 'VulnerabilityScanner'},
                            {'Name': 'FailureType', 'Value': failure_type}
                        ]
                    }
                ]
            )
        except Exception as e:
            logger.error(
                "failed_to_record_failure_metric",
                correlation_id=self.correlation_id,
                error=str(e)
            )

@xray_recorder.capture('lambda_handler')
def lambda_handler(event, context):
    """AWS Lambda handler for vulnerability scanner microservice"""
    
    # Add correlation ID to X-Ray
    correlation_id = str(uuid.uuid4())
    xray_recorder.current_segment().put_annotation('correlation_id', correlation_id)
    
    logger.info(
        "vulnerability_scanner_invoked",
        correlation_id=correlation_id,
        event=event,
        function_name=context.function_name,
        function_version=context.function_version
    )
    
    try:
        scanner = VulnerabilityScannerMicroservice()
        
        # Extract scan parameters from event
        scan_params = {
            'scan_type': event.get('scanType', 'patches'),
            'days_back': event.get('daysBack', 7),
            'include_inspector': event.get('includeInspector', True),
            'include_patches': event.get('includePatches', True)
        }
        
        result = scanner.scan_vulnerabilities(scan_params)
        
        logger.info(
            "vulnerability_scanner_completed",
            correlation_id=correlation_id,
            result=result
        )
        
        return {
            'statusCode': 200,
            'body': json.dumps(result),
            'headers': {
                'Content-Type': 'application/json',
                'X-Correlation-ID': correlation_id
            }
        }
        
    except Exception as e:
        logger.error(
            "vulnerability_scanner_failed",
            correlation_id=correlation_id,
            error=str(e),
            error_type=type(e).__name__
        )
        
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': str(e),
                'correlation_id': correlation_id,
                'error_type': type(e).__name__
            }),
            'headers': {
                'Content-Type': 'application/json',
                'X-Correlation-ID': correlation_id
            }
        }